# 基础数据结构

## 栈和队列

### 线性表基础

- 数组实现
- 链表实现
    - 哨兵链表，双向循环链表
- 补充，稀疏矩阵（sparse matrix）是大部分元素均为 0 的矩阵
    - 多维数组实现，空间浪费严重
    - 多重链表（multilist）实现，也称十字链表（orthogonal linked list）
- 补充，链表的游标实现（no pointer）
    - 使用全局结构体数组来实现链表，维护其中一个分区 freelist 来实现 malloc 和 free

### 栈和队列

- 栈（stack）是 last-in-first-out (LIFO) 的

    ```c
    struct Stack {
        int Capacity;
        int TopOfStack;
        ElementType *Array;
    }
    ```

- 栈的基本操作：
    - 入栈（push），将元素压入栈顶
    - 出栈（pop），将栈顶元素出栈
    - 查看栈顶元素（top）
- 队列（queue）是 first-in-first-out (FIFO) 的

    ```c
    struct Queue {
        int Capacity;
        int Front, Rear;
        ElementType *Array;
    }
    ```

- 队列的基本操作：
    - 入队（enqueue），在队尾插入元素
    - 出队（dequeue），在队首弹出元素
- 循环队列

### 中缀、后缀与前缀

- 后缀（postfix）表达式，所有操作符置于操作数的后面
    - 后缀表达式不再考虑运算符的优先级，也不需要括号
- 后缀表达式求值，$\Omicron(N)$，维护一个操作数栈
    1. 读到操作数，入栈
    2. 读到操作符，将栈顶前两个操作数依次出栈，进行运算，并把运算结果入栈
    3. 表达式读完后，将栈顶元素出栈，即为表达式的值
- 中缀表达式转后缀表达式，维护一个操作符栈
    1. 读到操作数，直接输出
    2. 读到操作符，将其与栈顶操作符比较优先级
        - pre(top) >= pre(tmp)，栈顶操作符出栈，并重复步骤 b.
        - pre(top) < pre(tmp) 或者栈为空，操作符直接入栈
        - 注意，读到左括号直接入栈，读到右括号将栈中元素依次出栈直至左括号，丢弃这对括号
        - 注意，上述针对左结合操作符，对于右结合操作符（如 $\text{\textasciicircum}$），优先级相等时直接入栈
    3. 表达式读完后，将栈中元素全部依次出栈
- 前缀（prefix）表达式，所有操作符置于操作数的前面
    - 前缀表达式不再考虑运算符的优先级，也不需要括号
- 前缀表达式求值，和后缀求值基本一致，唯一区别是前缀自右向左扫描表达式
- 中缀表达式转前缀表达式，和中缀转后缀基本一致，区别如下：
    - 自右向左扫描表达式
    - 左括号和右括号相反
    - 左结合操作符和右结合操作符相反，体现在优先级相等时的处理
- 表达式树（expression tree）是一种二叉树，叶子节点均为操作数，其余节点均为操作符
- 中缀表达式建树，维护两个栈，optr 栈存储操作符，expt 栈存储表达式树根节点
    1. 读到操作数，生成一个只有根节点的表达式树，入栈 expt
    2. 读到操作符，将其与 optr 栈顶操作符比较优先级
        - pre(top) >= pre(tmp)，栈顶操作符出栈，将 expt 栈顶前两棵树出栈，生成以该操作符为根节点、以这两棵树为左右子树的表达式树，入栈 expt；重复步骤 b.
        - pre(top) < pre(tmp) 或者栈为空，操作符直接入栈
        - 注意，读到左括号直接入栈，读到右括号将栈中元素依次出栈直至左括号，丢弃这对括号
        - 注意，上述针对左结合操作符，对于右结合操作符（如 $\text{\textasciicircum}$），优先级相等时直接入栈
    3. 表达式读完后，将 expt 栈顶元素出栈，即为表达式树

## 树

### 基础概念

- 树由根节点（root），以及 0 个或多个非空子树与根通过一条有向边（edge）连接组成
- 一棵树是 $N$ 个节点和 $N-1$ 条边的集合
- 节点的子树数量称为节点的度（degree）
- 一棵树的度是这棵树里所有节点度的最大值
- 有不止一个子树的节点称为父亲（parent）
- 父亲的每棵子树的根节点称为儿子（children）
- 有相同父亲的儿子称为兄弟（siblings）
- 没有子树的节点称为树叶（leaf）
- 从节点 $n_1$ 到 $n_k$ 的路径（path）是唯一的，其长度（length）是路径上边的数量
- 节点 $n_i$ 的深度（depth）是从根到 $n_i$ 的唯一路径的长度
- 节点 $n_i$ 的高度（height）是从 $n_i$ 到一个叶节点的最长长度
- 树的高度 / 深度 = 根节点的高度 = 最深叶节点的深度
- 一个节点的祖先（ancestor）是从根到这个节点的路径上的所有节点
- 一个节点的后裔（descendants）是这个节点的子树中的所有节点

### 二叉树

- 树的表示：
    - 列表表示，子节点个数未知，不易表示
    - FirstChild-NextSibling 表示，因为儿子顺序不定，所以一棵树的表示方式不唯一

        ```c
        struct TreeNode {
            ElementType Element;
            PtrToNode FirstChild, NextSibling;
        };
        typedef struct TreeNode *PtrToNode;
        ```
    - 将 FirstChild-NextSibling 表示的树顺时针旋转 $45\degree$，可以得到二叉树
- 二叉树（binary tree）是每个节点最多有两个儿子的树